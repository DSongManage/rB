{"version":3,"file":"ComicPageRenderer-DXyGNhLX.js","sources":["../../src/components/reader/SpeechBubbleDisplay.tsx","../../src/components/reader/ComicPageRenderer.tsx"],"sourcesContent":["/**\n * SpeechBubbleDisplay Component\n *\n * Read-only display of speech bubbles in comic panels.\n * Supports various bubble types with appropriate styling.\n */\n\nimport React from 'react';\nimport { SpeechBubbleData } from '../../services/libraryApi';\n\ninterface SpeechBubbleDisplayProps {\n  bubble: SpeechBubbleData;\n}\n\nexport function SpeechBubbleDisplay({ bubble }: SpeechBubbleDisplayProps) {\n  // Get bubble border radius based on type\n  const getBubbleBorderRadius = (): string => {\n    switch (bubble.bubble_type) {\n      case 'oval':\n      case 'thought':\n        return '50%';\n      case 'shout':\n      case 'burst':\n        return '8px';\n      case 'narrative':\n      case 'caption':\n        return '4px';\n      case 'whisper':\n        return '40%';\n      case 'radio':\n        return '12px';\n      default:\n        return '50%';\n    }\n  };\n\n  // Get additional styling based on bubble type\n  const getBubbleTypeStyle = (): React.CSSProperties => {\n    const baseStyle: React.CSSProperties = {};\n\n    switch (bubble.bubble_type) {\n      case 'thought':\n        // Thought bubbles have a cloud-like appearance\n        baseStyle.boxShadow = '4px 4px 0 rgba(0,0,0,0.1)';\n        break;\n      case 'shout':\n        // Shout bubbles are more angular\n        baseStyle.fontWeight = 'bold';\n        break;\n      case 'whisper':\n        // Whisper bubbles are subtle\n        baseStyle.opacity = 0.9;\n        baseStyle.fontStyle = 'italic';\n        break;\n      case 'narrative':\n      case 'caption':\n        // Narrative boxes are rectangular\n        baseStyle.fontStyle = 'italic';\n        break;\n      case 'radio':\n        // Radio/electronic speech\n        baseStyle.border = `2px dashed ${bubble.border_color}`;\n        break;\n    }\n\n    return baseStyle;\n  };\n\n  return (\n    <div\n      style={{\n        position: 'absolute',\n        left: `${bubble.x_percent}%`,\n        top: `${bubble.y_percent}%`,\n        width: `${bubble.width_percent}%`,\n        height: `${bubble.height_percent}%`,\n        zIndex: bubble.z_index,\n        backgroundColor: bubble.background_color || '#ffffff',\n        border: `${bubble.border_width}px solid ${bubble.border_color || '#000000'}`,\n        borderRadius: getBubbleBorderRadius(),\n        display: 'flex',\n        alignItems: 'center',\n        justifyContent: 'center',\n        padding: '8%',\n        boxSizing: 'border-box',\n        overflow: 'hidden',\n        ...getBubbleTypeStyle(),\n      }}\n    >\n      <span\n        style={{\n          fontFamily: bubble.font_family || 'Comic Sans MS, cursive, sans-serif',\n          fontSize: `${bubble.font_size || 14}px`,\n          color: bubble.font_color || '#000000',\n          fontWeight: bubble.font_weight || 'normal',\n          fontStyle: bubble.font_style || 'normal',\n          textAlign: (bubble.text_align as 'left' | 'center' | 'right') || 'center',\n          lineHeight: 1.3,\n          wordWrap: 'break-word',\n          overflowWrap: 'break-word',\n          width: '100%',\n        }}\n      >\n        {bubble.text}\n      </span>\n    </div>\n  );\n}\n\nexport default SpeechBubbleDisplay;\n","/**\n * ComicPageRenderer Component\n *\n * Renders a single comic page using SVG with polygon clipping.\n * Uses divider lines to compute panel regions, matching the editor's rendering.\n * Maintains aspect ratio and supports zoom.\n */\n\nimport React, { useRef, useState, useEffect, useMemo } from 'react';\nimport { ComicPageData, ComicPanelData } from '../../services/libraryApi';\nimport { computePanelRegions, ComputedPanel, DividerLine } from '../../utils/regionCalculator';\nimport { SpeechBubbleDisplay } from './SpeechBubbleDisplay';\n\ninterface ComicPageRendererProps {\n  page: ComicPageData;\n  zoom: number;\n  /** When true, scales page to fit within container bounds (like object-fit: contain) */\n  fitToContainer?: boolean;\n}\n\n/**\n * Convert point vertices to SVG polygon points string.\n */\nfunction verticesToPoints(\n  vertices: { x: number; y: number }[],\n  canvasWidth: number,\n  canvasHeight: number\n): string {\n  return vertices\n    .map((v) => {\n      // Vertices are in pixels (from computePanelRegions), already scaled\n      return `${v.x},${v.y}`;\n    })\n    .join(' ');\n}\n\n/**\n * Find the API panel that best matches a computed panel region.\n * Matches based on centroid proximity.\n */\nfunction findMatchingPanel(\n  computedPanel: ComputedPanel,\n  apiPanels: ComicPanelData[],\n  canvasWidth: number,\n  canvasHeight: number\n): ComicPanelData | null {\n  if (apiPanels.length === 0) return null;\n\n  // Convert computed centroid to percentage for comparison\n  const computedCentroidXPercent = (computedPanel.centroid.x / canvasWidth) * 100;\n  const computedCentroidYPercent = (computedPanel.centroid.y / canvasHeight) * 100;\n\n  let bestMatch: ComicPanelData | null = null;\n  let bestDistance = Infinity;\n\n  for (const panel of apiPanels) {\n    // Parse values as numbers (API may return strings)\n    const xPercent = Number(panel.x_percent);\n    const yPercent = Number(panel.y_percent);\n    const widthPercent = Number(panel.width_percent);\n    const heightPercent = Number(panel.height_percent);\n\n    // Calculate API panel's centroid in percentage\n    const panelCentroidX = xPercent + widthPercent / 2;\n    const panelCentroidY = yPercent + heightPercent / 2;\n\n    // Calculate distance\n    const dx = panelCentroidX - computedCentroidXPercent;\n    const dy = panelCentroidY - computedCentroidYPercent;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n\n    if (distance < bestDistance) {\n      bestDistance = distance;\n      bestMatch = panel;\n    }\n  }\n\n  // Only return match if it's reasonably close (within 20% of canvas)\n  if (bestDistance < 20) {\n    return bestMatch;\n  }\n\n  return null;\n}\n\nexport function ComicPageRenderer({ page, zoom, fitToContainer = false }: ComicPageRendererProps) {\n  const containerRef = useRef<HTMLDivElement>(null);\n  const [containerSize, setContainerSize] = useState({ width: 0, height: 0 });\n\n  // Calculate aspect ratio from canvas dimensions\n  const aspectRatio = page.canvas_width / page.canvas_height;\n\n  // Observe container size changes when fitToContainer is enabled\n  useEffect(() => {\n    if (!fitToContainer || !containerRef.current) return;\n\n    const observer = new ResizeObserver((entries) => {\n      const entry = entries[0];\n      if (entry) {\n        setContainerSize({\n          width: entry.contentRect.width,\n          height: entry.contentRect.height,\n        });\n      }\n    });\n\n    observer.observe(containerRef.current);\n    return () => observer.disconnect();\n  }, [fitToContainer]);\n\n  // Convert API divider lines to the format expected by regionCalculator\n  const dividerLines: DividerLine[] = useMemo(() => {\n    if (!page.divider_lines) return [];\n    return page.divider_lines.map(line => ({\n      id: line.id,\n      line_type: line.line_type,\n      start_x: line.start_x,\n      start_y: line.start_y,\n      end_x: line.end_x,\n      end_y: line.end_y,\n      control1_x: line.control1_x,\n      control1_y: line.control1_y,\n      control2_x: line.control2_x,\n      control2_y: line.control2_y,\n    }));\n  }, [page.divider_lines]);\n\n  // Compute panel regions from divider lines\n  const computedPanels = useMemo(() => {\n    return computePanelRegions(dividerLines, page.canvas_width, page.canvas_height);\n  }, [dividerLines, page.canvas_width, page.canvas_height]);\n\n  // Match computed panels with API panels to get artwork URLs\n  const panelMatches = useMemo(() => {\n    const matches = new Map<string, ComicPanelData>();\n    const usedPanels = new Set<number>();\n\n    // Only consider panels that have artwork\n    const panelsWithArtwork = page.panels.filter(p => p.artwork);\n\n    for (const computed of computedPanels) {\n      const match = findMatchingPanel(\n        computed,\n        panelsWithArtwork.filter(p => !usedPanels.has(p.id)),\n        page.canvas_width,\n        page.canvas_height\n      );\n      if (match) {\n        matches.set(computed.id, match);\n        usedPanels.add(match.id);\n      }\n    }\n\n    return matches;\n  }, [computedPanels, page.panels, page.canvas_width, page.canvas_height]);\n\n  // Calculate fitted dimensions when fitToContainer is enabled\n  let pageWidth: number | string = zoom <= 1 ? `calc(100% * ${zoom})` : `${zoom * 100}%`;\n  let pageHeight: number | string = 'auto';\n  let useAspectRatio = true;\n  let renderedWidth = page.canvas_width;\n  let renderedHeight = page.canvas_height;\n\n  if (fitToContainer && containerSize.width > 0 && containerSize.height > 0) {\n    // Leave some breathing room (use 92% of container to avoid edge-to-edge)\n    const availableWidth = containerSize.width * 0.92;\n    const availableHeight = containerSize.height * 0.92;\n    const containerAspect = availableWidth / availableHeight;\n\n    if (aspectRatio > containerAspect) {\n      // Page is wider than container - constrain by width\n      renderedWidth = availableWidth;\n      renderedHeight = availableWidth / aspectRatio;\n    } else {\n      // Page is taller than container - constrain by height\n      renderedHeight = availableHeight;\n      renderedWidth = availableHeight * aspectRatio;\n    }\n    // Apply zoom to the fitted dimensions\n    pageWidth = renderedWidth * zoom;\n    pageHeight = renderedHeight * zoom;\n    useAspectRatio = false;\n  }\n\n  // For non-fitted mode, use canvas dimensions\n  if (!fitToContainer || containerSize.width === 0) {\n    renderedWidth = page.canvas_width;\n    renderedHeight = page.canvas_height;\n  }\n\n  // Calculate scale factor for polygon vertices\n  const scaleX = renderedWidth / page.canvas_width;\n  const scaleY = renderedHeight / page.canvas_height;\n\n  return (\n    <div\n      ref={containerRef}\n      style={{\n        width: '100%',\n        height: '100%',\n        display: 'flex',\n        alignItems: 'center',\n        justifyContent: 'center',\n        overflow: zoom > 1 ? 'auto' : 'hidden',\n      }}\n    >\n      <div\n        style={{\n          width: pageWidth,\n          height: fitToContainer ? pageHeight : 'auto',\n          maxWidth: fitToContainer ? 'none' : (zoom <= 1 ? '100%' : 'none'),\n          aspectRatio: useAspectRatio ? `${aspectRatio}` : undefined,\n          maxHeight: fitToContainer ? 'none' : (zoom <= 1 ? '100%' : 'none'),\n          position: 'relative',\n          backgroundColor: page.background_color || '#ffffff',\n          boxShadow: '0 4px 20px rgba(0, 0, 0, 0.3)',\n          transition: fitToContainer ? 'none' : 'width 0.2s ease, max-width 0.2s ease',\n          flexShrink: 0,\n        }}\n      >\n        {/* SVG for polygon-clipped panel rendering */}\n        <svg\n          width=\"100%\"\n          height=\"100%\"\n          viewBox={`0 0 ${page.canvas_width} ${page.canvas_height}`}\n          preserveAspectRatio=\"xMidYMid meet\"\n          style={{\n            position: 'absolute',\n            top: 0,\n            left: 0,\n            width: '100%',\n            height: '100%',\n          }}\n        >\n          {/* Background image if present */}\n          {page.background_image && (\n            <image\n              href={page.background_image}\n              x={0}\n              y={0}\n              width={page.canvas_width}\n              height={page.canvas_height}\n              preserveAspectRatio=\"xMidYMid slice\"\n            />\n          )}\n\n          {/* Define clip paths for each panel */}\n          <defs>\n            {computedPanels.map((panel) => (\n              <clipPath key={`clip-${panel.id}`} id={`reader-clip-${panel.id}`}>\n                <polygon points={verticesToPoints(panel.vertices, page.canvas_width, page.canvas_height)} />\n              </clipPath>\n            ))}\n          </defs>\n\n          {/* Render panels with artwork clipped to polygon shapes */}\n          {computedPanels.map((computedPanel, index) => {\n            const apiPanel = panelMatches.get(computedPanel.id);\n            const artworkUrl = apiPanel?.artwork;\n            const backgroundColor = apiPanel?.background_color || '#ffffff';\n            const borderColor = apiPanel?.border_color || '#000000';\n            const borderWidth = apiPanel?.border_width ?? 2;\n            const borderStyle = apiPanel?.border_style || 'solid';\n\n            return (\n              <g key={computedPanel.id}>\n                {/* Panel background */}\n                <polygon\n                  points={verticesToPoints(computedPanel.vertices, page.canvas_width, page.canvas_height)}\n                  fill={backgroundColor}\n                  stroke={borderStyle !== 'none' ? borderColor : 'none'}\n                  strokeWidth={borderStyle !== 'none' ? borderWidth : 0}\n                />\n\n                {/* Artwork clipped to panel shape */}\n                {artworkUrl && (\n                  <image\n                    href={artworkUrl}\n                    x={computedPanel.bounds.x}\n                    y={computedPanel.bounds.y}\n                    width={computedPanel.bounds.width}\n                    height={computedPanel.bounds.height}\n                    preserveAspectRatio=\"xMidYMid slice\"\n                    clipPath={`url(#reader-clip-${computedPanel.id})`}\n                  />\n                )}\n              </g>\n            );\n          })}\n        </svg>\n\n        {/* Speech bubbles - rendered as HTML overlays on top of SVG */}\n        {/* Bubble positions are stored as page-relative percentages (0-100) */}\n        {page.panels &&\n          page.panels.flatMap((panel) =>\n            (panel.speech_bubbles || []).map((bubble) => (\n              <SpeechBubbleDisplay key={bubble.id} bubble={bubble} />\n            ))\n          )}\n      </div>\n    </div>\n  );\n}\n\nexport default ComicPageRenderer;\n"],"names":["SpeechBubbleDisplay","bubble","jsx","style","position","left","x_percent","top","y_percent","width","width_percent","height","height_percent","zIndex","z_index","backgroundColor","background_color","border","border_width","border_color","borderRadius","bubble_type","getBubbleBorderRadius","display","alignItems","justifyContent","padding","boxSizing","overflow","baseStyle","boxShadow","fontWeight","opacity","fontStyle","getBubbleTypeStyle","children","fontFamily","font_family","fontSize","font_size","color","font_color","font_weight","font_style","textAlign","text_align","lineHeight","wordWrap","overflowWrap","text","verticesToPoints","vertices","canvasWidth","canvasHeight","map","v","x","y","join","findMatchingPanel","computedPanel","apiPanels","length","computedCentroidXPercent","centroid","computedCentroidYPercent","bestMatch","bestDistance","Infinity","panel","xPercent","Number","yPercent","dx","dy","distance","Math","sqrt","ComicPageRenderer","page","zoom","fitToContainer","containerRef","useRef","containerSize","setContainerSize","useState","aspectRatio","canvas_width","canvas_height","useEffect","current","observer","ResizeObserver","entries","entry","contentRect","observe","disconnect","dividerLines","useMemo","divider_lines","line","id","line_type","start_x","start_y","end_x","end_y","control1_x","control1_y","control2_x","control2_y","computedPanels","computePanelRegions","panelMatches","matches","Map","usedPanels","Set","panelsWithArtwork","panels","filter","p","artwork","computed","match","has","set","add","pageWidth","pageHeight","useAspectRatio","renderedWidth","renderedHeight","availableWidth","availableHeight","ref","jsxs","maxWidth","maxHeight","transition","flexShrink","viewBox","preserveAspectRatio","background_image","href","points","index","apiPanel","get","artworkUrl","borderColor","borderWidth","borderStyle","border_style","fill","stroke","strokeWidth","bounds","clipPath","flatMap","speech_bubbles"],"mappings":"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"}