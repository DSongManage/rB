{"version":3,"file":"socialApi-DW9NOArw.js","sources":["../../src/services/socialApi.ts"],"sourcesContent":["/**\n * Social Engagement API Service\n *\n * Provides functions for managing likes, comments, ratings, and creator reviews.\n */\n\nimport { API_URL as API_BASE } from '../config';\n\n// ===== TypeScript Interfaces =====\n\nexport interface ContentLike {\n  id: number;\n  user: number;\n  username: string;\n  user_avatar: string;\n  content: number;\n  created_at: string;\n}\n\nexport interface ContentComment {\n  id: number;\n  content: number;\n  author: number;\n  author_username: string;\n  author_avatar: string;\n  text: string;\n  parent_comment: number | null;\n  edited: boolean;\n  is_deleted: boolean;\n  created_at: string;\n  updated_at: string;\n  replies_count: number;\n  can_delete: boolean;\n  can_edit: boolean;\n  thread_depth: number;\n  replies?: ContentComment[];\n}\n\nexport interface ContentRating {\n  id: number;\n  user: number;\n  username: string;\n  user_avatar: string;\n  content: number;\n  rating: number;\n  review_text: string;\n  created_at: string;\n  updated_at: string;\n}\n\nexport interface CreatorReview {\n  id: number;\n  reviewer: number;\n  reviewer_username: string;\n  reviewer_avatar: string;\n  creator: number;\n  creator_username: string;\n  rating: number;\n  review_text: string;\n  verification_type: 'purchase' | 'collaboration';\n  verification_display: string;\n  response_text: string;\n  response_at: string | null;\n  created_at: string;\n  updated_at: string;\n}\n\nexport interface LikeToggleResponse {\n  liked: boolean;\n  like_count: number;\n}\n\nexport interface CanReviewResponse {\n  can_review: boolean;\n  verification_type: 'purchase' | 'collaboration' | null;\n  reason: string | null;\n}\n\nexport interface FollowStatusResponse {\n  following: boolean;\n  follower_count: number;\n}\n\nexport interface FollowUser {\n  id: number;\n  username: string;\n  display_name: string;\n  avatar: string | null;\n  bio: string | null;\n  followed_at: string;\n}\n\nexport interface FeedItem {\n  id: number;\n  title: string;\n  content_type: string;\n  genre: string;\n  price_usd: string;\n  cover_image: string | null;\n  view_count: number;\n  like_count: number;\n  created_at: string;\n  creator: {\n    id: number;\n    username: string;\n    display_name: string;\n    avatar: string | null;\n  };\n}\n\nexport interface PaginatedResponse<T> {\n  count: number;\n  next: string | null;\n  previous: string | null;\n  results: T[];\n}\n\n// ===== Helper Functions =====\n\n// CSRF token cache to prevent rate limiting\nlet cachedCsrfToken: string | null = null;\nlet csrfTokenExpiry: number = 0;\nconst CSRF_CACHE_DURATION = 5 * 60 * 1000; // 5 minutes\n\n/**\n * Get CSRF token from cookies (fallback)\n */\nfunction getCsrfFromCookie(): string {\n  const match = document.cookie.match(/csrftoken=([^;]+)/);\n  return match ? match[1] : '';\n}\n\n/**\n * Get CSRF token with caching to prevent rate limiting\n */\nasync function getCsrfToken(): Promise<string> {\n  const now = Date.now();\n\n  // Return cached token if still valid\n  if (cachedCsrfToken && now < csrfTokenExpiry) {\n    return cachedCsrfToken;\n  }\n\n  // Try to get from cookie first (fastest)\n  const cookieToken = getCsrfFromCookie();\n  if (cookieToken && cookieToken.length === 64) {\n    cachedCsrfToken = cookieToken;\n    csrfTokenExpiry = now + CSRF_CACHE_DURATION;\n    return cookieToken;\n  }\n\n  // Fetch fresh token from API\n  try {\n    const response = await fetch(`${API_BASE}/api/auth/csrf/`, {\n      credentials: 'include',\n    });\n    if (response.ok) {\n      const data = await response.json();\n      const token = data?.csrfToken || '';\n      if (token) {\n        cachedCsrfToken = token;\n        csrfTokenExpiry = now + CSRF_CACHE_DURATION;\n        return token;\n      }\n    }\n  } catch (error) {\n    console.error('Failed to fetch CSRF token:', error);\n  }\n\n  // Final fallback to cookie even if not 64 chars\n  return getCsrfFromCookie();\n}\n\nasync function getAuthHeaders(): Promise<HeadersInit> {\n  const csrfToken = await getCsrfToken();\n  return {\n    'Content-Type': 'application/json',\n    'X-CSRFToken': csrfToken,\n    'X-Requested-With': 'XMLHttpRequest',\n  };\n}\n\nasync function handleResponse<T>(response: Response): Promise<T> {\n  if (!response.ok) {\n    const error = await response.json().catch(() => ({ error: 'Request failed' }));\n    throw new Error(error.error || error.detail || 'Request failed');\n  }\n  return response.json();\n}\n\n// ===== Content Likes =====\n\nexport async function toggleLike(contentId: number): Promise<LikeToggleResponse> {\n  const headers = await getAuthHeaders();\n  const response = await fetch(`${API_BASE}/api/content/${contentId}/like/`, {\n    method: 'POST',\n    headers,\n    credentials: 'include',\n  });\n  return handleResponse<LikeToggleResponse>(response);\n}\n\nexport async function getLikeStatus(contentId: number): Promise<LikeToggleResponse> {\n  const headers = await getAuthHeaders();\n  const response = await fetch(`${API_BASE}/api/content/${contentId}/like/`, {\n    method: 'GET',\n    headers,\n    credentials: 'include',\n  });\n  return handleResponse<LikeToggleResponse>(response);\n}\n\n// ===== Content Comments =====\n\nexport async function getContentComments(\n  contentId: number,\n  page: number = 1,\n  topLevelOnly: boolean = true\n): Promise<PaginatedResponse<ContentComment>> {\n  const params = new URLSearchParams({\n    content: contentId.toString(),\n    page: page.toString(),\n    top_level: topLevelOnly.toString(),\n  });\n\n  const response = await fetch(`${API_BASE}/api/content-comments/?${params}`, {\n    credentials: 'include',\n  });\n  return handleResponse<PaginatedResponse<ContentComment>>(response);\n}\n\nexport async function getCommentReplies(commentId: number): Promise<ContentComment[]> {\n  const response = await fetch(`${API_BASE}/api/content-comments/${commentId}/replies/`, {\n    credentials: 'include',\n  });\n  return handleResponse<ContentComment[]>(response);\n}\n\nexport async function createComment(\n  contentId: number,\n  text: string,\n  parentCommentId?: number\n): Promise<ContentComment> {\n  const headers = await getAuthHeaders();\n  const response = await fetch(`${API_BASE}/api/content-comments/`, {\n    method: 'POST',\n    headers,\n    credentials: 'include',\n    body: JSON.stringify({\n      content: contentId,\n      text,\n      parent_comment: parentCommentId || null,\n    }),\n  });\n  return handleResponse<ContentComment>(response);\n}\n\nexport async function updateComment(\n  commentId: number,\n  text: string\n): Promise<ContentComment> {\n  const headers = await getAuthHeaders();\n  const response = await fetch(`${API_BASE}/api/content-comments/${commentId}/`, {\n    method: 'PATCH',\n    headers,\n    credentials: 'include',\n    body: JSON.stringify({ text }),\n  });\n  return handleResponse<ContentComment>(response);\n}\n\nexport async function deleteComment(commentId: number): Promise<void> {\n  const headers = await getAuthHeaders();\n  const response = await fetch(`${API_BASE}/api/content-comments/${commentId}/`, {\n    method: 'DELETE',\n    headers,\n    credentials: 'include',\n  });\n  if (!response.ok) {\n    const error = await response.json().catch(() => ({ error: 'Request failed' }));\n    throw new Error(error.error || error.detail || 'Request failed');\n  }\n}\n\n// ===== Content Ratings =====\n\nexport async function getContentRatings(\n  contentId: number,\n  page: number = 1\n): Promise<PaginatedResponse<ContentRating>> {\n  const params = new URLSearchParams({\n    content: contentId.toString(),\n    page: page.toString(),\n  });\n\n  const response = await fetch(`${API_BASE}/api/content-ratings/?${params}`, {\n    credentials: 'include',\n  });\n  return handleResponse<PaginatedResponse<ContentRating>>(response);\n}\n\nexport async function getMyRating(contentId: number): Promise<ContentRating | null> {\n  const headers = await getAuthHeaders();\n  const response = await fetch(`${API_BASE}/api/content-ratings/mine/?content=${contentId}`, {\n    headers,\n    credentials: 'include',\n  });\n\n  if (!response.ok) {\n    if (response.status === 404) return null;\n    const error = await response.json().catch(() => ({ error: 'Request failed' }));\n    throw new Error(error.error || error.detail || 'Request failed');\n  }\n\n  const data = await response.json();\n  return data || null;\n}\n\nexport async function submitRating(\n  contentId: number,\n  rating: number,\n  reviewText?: string\n): Promise<ContentRating> {\n  const headers = await getAuthHeaders();\n  const response = await fetch(`${API_BASE}/api/content-ratings/`, {\n    method: 'POST',\n    headers,\n    credentials: 'include',\n    body: JSON.stringify({\n      content: contentId,\n      rating,\n      review_text: reviewText || '',\n    }),\n  });\n  return handleResponse<ContentRating>(response);\n}\n\n// ===== Creator Reviews =====\n\nexport async function getCreatorReviews(\n  username: string,\n  page: number = 1\n): Promise<PaginatedResponse<CreatorReview>> {\n  const params = new URLSearchParams({\n    creator: username,\n    page: page.toString(),\n  });\n\n  const response = await fetch(`${API_BASE}/api/creator-reviews/?${params}`, {\n    credentials: 'include',\n  });\n  return handleResponse<PaginatedResponse<CreatorReview>>(response);\n}\n\nexport async function canReviewCreator(userId: number): Promise<CanReviewResponse> {\n  const headers = await getAuthHeaders();\n  const response = await fetch(`${API_BASE}/api/creator-reviews/can-review/${userId}/`, {\n    headers,\n    credentials: 'include',\n  });\n  return handleResponse<CanReviewResponse>(response);\n}\n\nexport async function submitCreatorReview(\n  creatorId: number,\n  rating: number,\n  reviewText?: string\n): Promise<CreatorReview> {\n  const headers = await getAuthHeaders();\n  const response = await fetch(`${API_BASE}/api/creator-reviews/`, {\n    method: 'POST',\n    headers,\n    credentials: 'include',\n    body: JSON.stringify({\n      creator: creatorId,\n      rating,\n      review_text: reviewText || '',\n    }),\n  });\n  return handleResponse<CreatorReview>(response);\n}\n\nexport async function respondToReview(\n  reviewId: number,\n  responseText: string\n): Promise<CreatorReview> {\n  const headers = await getAuthHeaders();\n  const response = await fetch(`${API_BASE}/api/creator-reviews/${reviewId}/respond/`, {\n    method: 'POST',\n    headers,\n    credentials: 'include',\n    body: JSON.stringify({ response_text: responseText }),\n  });\n  return handleResponse<CreatorReview>(response);\n}\n\n// ===== User Following =====\n\nexport async function followUser(username: string): Promise<FollowStatusResponse> {\n  const headers = await getAuthHeaders();\n  const response = await fetch(`${API_BASE}/api/users/${username}/follow/`, {\n    method: 'POST',\n    headers,\n    credentials: 'include',\n  });\n  return handleResponse<FollowStatusResponse>(response);\n}\n\nexport async function unfollowUser(username: string): Promise<FollowStatusResponse> {\n  const headers = await getAuthHeaders();\n  const response = await fetch(`${API_BASE}/api/users/${username}/follow/`, {\n    method: 'DELETE',\n    headers,\n    credentials: 'include',\n  });\n  return handleResponse<FollowStatusResponse>(response);\n}\n\nexport async function getFollowStatus(username: string): Promise<FollowStatusResponse> {\n  const headers = await getAuthHeaders();\n  const response = await fetch(`${API_BASE}/api/users/${username}/follow/`, {\n    method: 'GET',\n    headers,\n    credentials: 'include',\n  });\n  return handleResponse<FollowStatusResponse>(response);\n}\n\nexport async function getFollowers(\n  username: string,\n  page: number = 1\n): Promise<PaginatedResponse<FollowUser>> {\n  const params = new URLSearchParams({ page: page.toString() });\n  const response = await fetch(`${API_BASE}/api/users/${username}/followers/?${params}`, {\n    credentials: 'include',\n  });\n  return handleResponse<PaginatedResponse<FollowUser>>(response);\n}\n\nexport async function getFollowing(\n  username: string,\n  page: number = 1\n): Promise<PaginatedResponse<FollowUser>> {\n  const params = new URLSearchParams({ page: page.toString() });\n  const response = await fetch(`${API_BASE}/api/users/${username}/following/?${params}`, {\n    credentials: 'include',\n  });\n  return handleResponse<PaginatedResponse<FollowUser>>(response);\n}\n\nexport async function getFollowingFeed(\n  page: number = 1\n): Promise<PaginatedResponse<FeedItem>> {\n  const headers = await getAuthHeaders();\n  const params = new URLSearchParams({ page: page.toString() });\n  const response = await fetch(`${API_BASE}/api/feed/following/?${params}`, {\n    headers,\n    credentials: 'include',\n  });\n  return handleResponse<PaginatedResponse<FeedItem>>(response);\n}\n\n// ===== Default Export =====\n\nexport const socialApi = {\n  // Likes\n  toggleLike,\n  getLikeStatus,\n\n  // Comments\n  getContentComments,\n  getCommentReplies,\n  createComment,\n  updateComment,\n  deleteComment,\n\n  // Ratings\n  getContentRatings,\n  getMyRating,\n  submitRating,\n\n  // Creator Reviews\n  getCreatorReviews,\n  canReviewCreator,\n  submitCreatorReview,\n  respondToReview,\n\n  // Following\n  followUser,\n  unfollowUser,\n  getFollowStatus,\n  getFollowers,\n  getFollowing,\n  getFollowingFeed,\n};\n\nexport default socialApi;\n"],"names":["cachedCsrfToken","csrfTokenExpiry","CSRF_CACHE_DURATION","getCsrfFromCookie","match","document","cookie","async","getAuthHeaders","now","Date","cookieToken","length","response","fetch","API_BASE","credentials","ok","data","json","token","csrfToken","error","getCsrfToken","handleResponse","catch","Error","detail","toggleLike","contentId","headers","method","getLikeStatus","getContentComments","page","topLevelOnly","params","URLSearchParams","content","toString","top_level","getCommentReplies","commentId","createComment","text","parentCommentId","body","JSON","stringify","parent_comment","updateComment","deleteComment","getContentRatings","getMyRating","status","submitRating","rating","reviewText","review_text","getCreatorReviews","username","creator","canReviewCreator","userId","submitCreatorReview","creatorId","respondToReview","reviewId","responseText","response_text","followUser","unfollowUser","getFollowStatus","getFollowing","getFollowingFeed"],"mappings":"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"}